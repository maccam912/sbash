#!/usr/bin/env bash
set -u

MODE="${SBASH_MODE:-normal}"
LLM_URL="${SBASH_LLM_URL:-}"
LLM_KEY="${SBASH_LLM_API_KEY:-}"
SCRIPT_SOURCE_URL="${SBASH_SOURCE_URL:-${SCRIPT_SOURCE_URL:-}}"

selected_provider="none"
provider_method="none"
provider_status="sbash: no LLM provider found; running without AI review"

select_provider() {
  if command -v codex >/dev/null 2>&1; then
    selected_provider="codex"
    provider_method="cli"
    provider_status="sbash: using codex CLI"
    return
  fi

  if command -v claude >/dev/null 2>&1; then
    selected_provider="claude"
    provider_method="cli"
    provider_status="sbash: using claude CLI"
    return
  fi

  if command -v gemini >/dev/null 2>&1; then
    selected_provider="gemini"
    provider_method="cli"
    provider_status="sbash: using gemini CLI"
    return
  fi

  if [ -n "${OPENAI_API_KEY:-}" ]; then
    selected_provider="openai"
    provider_method="api_key"
    provider_status="sbash: using OpenAI key"
    return
  fi

  if [ -n "${ANTHROPIC_API_KEY:-}" ]; then
    selected_provider="anthropic"
    provider_method="api_key"
    provider_status="sbash: using Anthropic key"
    return
  fi

  if [ -n "${GEMINI_API_KEY:-}" ]; then
    selected_provider="gemini"
    provider_method="api_key"
    provider_status="sbash: using Gemini key"
    return
  fi

  if [ -n "${OPENROUTER_API_KEY:-}" ]; then
    selected_provider="openrouter"
    provider_method="api_key"
    provider_status="sbash: using OpenRouter key"
    return
  fi
}

build_review_prompt() {
  # $1 = heuristic level, $2 = script text
  local heuristic="$1"
  local script="$2"
  local line_count
  local source_line=""

  line_count="$(printf '%s\n' "$script" | wc -l | awk '{print $1}')"
  if [ -n "$SCRIPT_SOURCE_URL" ]; then
    source_line="- source_url: $SCRIPT_SOURCE_URL\n"
  fi

  cat <<PROMPT
Role: quick triage for shell installer scripts.
Return JSON only (no markdown, no prose before/after). Use this exact schema:
{"decision":"allow|block|uncertain","reason":"short string","confidence":"low|medium|high"}
Instruction: prefer "uncertain" over over-asserting when evidence is incomplete.

Input:
- heuristic_level: $heuristic
${source_line}- size_lines: $line_count
- script_content:
$script
PROMPT
}

invoke_provider() {
  # $1 = prompt, $2 = output file
  local prompt="$1"
  local out="$2"

  if [ "$provider_method" = "cli" ]; then
    case "$selected_provider" in
      codex)
        codex "$prompt" >"$out" 2>/dev/null
        return $?
        ;;
      claude)
        claude "$prompt" >"$out" 2>/dev/null
        return $?
        ;;
      gemini)
        gemini "$prompt" >"$out" 2>/dev/null
        return $?
        ;;
    esac
    return 1
  fi

  if [ "$provider_method" = "api_key" ]; then
    [ -n "$LLM_URL" ] || return 1
    [ -n "${LLM_KEY:-}" ] || LLM_KEY="${OPENAI_API_KEY:-${ANTHROPIC_API_KEY:-${GEMINI_API_KEY:-${OPENROUTER_API_KEY:-}}}}"
    [ -n "$LLM_KEY" ] || return 1

    curl -sS -m 6 -X POST "$LLM_URL" \
      -H "Content-Type: application/json" \
      -H "Authorization: Bearer $LLM_KEY" \
      -d "{\"prompt\": $(printf '%s' "$prompt" | sed 's/\\/\\\\/g; s/\"/\\\"/g; :a;N;$!ba;s/\n/\\n/g' | awk '{printf "\"%s\"", $0}'), \"max_tokens\": 120 }" \
      >"$out"
    return $?
  fi

  return 1
}

tmp_script=""
tmp_ai=""
cleanup() {
  [ -n "$tmp_script" ] && [ -f "$tmp_script" ] && rm -f "$tmp_script"
  [ -n "$tmp_ai" ] && [ -f "$tmp_ai" ] && rm -f "$tmp_ai"
}
trap cleanup EXIT INT TERM

if [ -t 0 ]; then
  exec bash "$@"
fi

tmp_script="$(mktemp)" || {
  echo "sbash: failed to create temp file" >&2
  exit 1
}

cat >"$tmp_script"
script_text="$(cat "$tmp_script")"

heuristic_level="clear"
heuristic_reason=""

if printf '%s\n' "$script_text" | grep -Eiq '(^|[[:space:]])rm[[:space:]]+-rf[[:space:]]+/(\s|$|[^[:alnum:]_])'; then
  heuristic_level="dangerous"
  heuristic_reason="contains destructive root deletion pattern"
elif printf '%s\n' "$script_text" | grep -Eiq '(^|[[:space:]])(mkfs|fdisk|parted|wipefs)([[:space:]]|$)'; then
  heuristic_level="dangerous"
  heuristic_reason="contains disk formatting or partitioning command"
elif printf '%s\n' "$script_text" | grep -Eiq ':\(\)[[:space:]]*\{[[:space:]]*:[[:space:]]*\|[[:space:]]*:[[:space:]]*&[[:space:]]*\};[[:space:]]*:'; then
  heuristic_level="dangerous"
  heuristic_reason="contains fork bomb pattern"
elif printf '%s\n' "$script_text" | grep -Eiq '(^|[[:space:]])dd[[:space:]].*of=/dev/(sd[a-z]|nvme[0-9]+n[0-9]+|vd[a-z])'; then
  heuristic_level="dangerous"
  heuristic_reason="contains direct block-device overwrite command"
elif printf '%s\n' "$script_text" | grep -Fq 'SBASH_MALWARE_TEST_STRING'; then
  heuristic_level="dangerous"
  heuristic_reason="contains test malware signature string"
elif printf '%s\n' "$script_text" | grep -Eiq 'curl[^\n|;]*\|[[:space:]]*(sh|bash)\b|wget[^\n|;]*\|[[:space:]]*(sh|bash)\b'; then
  heuristic_level="suspicious"
  heuristic_reason="contains remote script piping into a shell"
elif printf '%s\n' "$script_text" | grep -Eiq '(^|[[:space:]])(sudo[[:space:]]+)?rm[[:space:]]+-rf[[:space:]]+~|(^|[[:space:]])eval[[:space:]]'; then
  heuristic_level="suspicious"
  heuristic_reason="contains risky command constructs"
fi

if [ "$heuristic_level" = "dangerous" ]; then
  echo "Blocked: $heuristic_reason." >&2
  exit 126
fi

llm_decision="unknown"
llm_reason=""
llm_parse_warning=""

select_provider
echo "$provider_status" >&2

if [ "$selected_provider" != "none" ] && [ "$heuristic_level" != "dangerous" ]; then
  tmp_ai="$(mktemp)" || {
    echo "sbash: failed to create temp file" >&2
    exit 1
  }

  prompt="$(build_review_prompt "$heuristic_level" "$script_text")"

  if ! invoke_provider "$prompt" "$tmp_ai"; then
    echo "sbash: provider call failed; running local-only safety checks" >&2
  fi

  ai_json="$(cat "$tmp_ai")"
  parsed_fields="$(printf '%s' "$ai_json" | python3 -c 'import json,sys
raw=sys.stdin.read().strip()
if not raw:
  sys.exit(2)
start=raw.find("{")
end=raw.rfind("}")
if start==-1 or end==-1 or end<start:
  sys.exit(2)
obj=json.loads(raw[start:end+1])
if not isinstance(obj,dict):
  sys.exit(2)
d=str(obj.get("decision",""))
r=str(obj.get("reason",""))
print(d.lower())
print(r.strip())
' 2>/dev/null)"

  if [ -n "$parsed_fields" ]; then
    llm_decision="$(printf '%s\n' "$parsed_fields" | sed -n '1p')"
    llm_reason="$(printf '%s\n' "$parsed_fields" | sed -n '2p')"
  else
    if [ "$MODE" = "cautious" ]; then
      llm_decision="uncertain"
      llm_reason="invalid AI JSON response"
      llm_parse_warning="invalid JSON from AI; defaulted to uncertain"
    else
      llm_decision="allow"
      llm_reason=""
      llm_parse_warning="invalid JSON from AI; allowed in non-cautious mode"
    fi
  fi
fi

allow="yes"
block_reason=""

if [ "$MODE" = "cautious" ]; then
  if [ "$heuristic_level" = "suspicious" ] && [ "$llm_decision" != "allow" ]; then
    allow="no"
    block_reason="suspicious script in cautious mode"
  elif [ "$llm_decision" = "block" ] || [ "$llm_decision" = "uncertain" ]; then
    allow="no"
    block_reason="AI checker did not confidently allow script"
  fi
else
  if [ "$llm_decision" = "block" ]; then
    allow="no"
    block_reason="AI checker flagged script"
  fi
fi

if [ -n "$llm_parse_warning" ]; then
  echo "sbash: $llm_parse_warning" >&2
fi

if [ "$allow" != "yes" ]; then
  if [ -n "$llm_reason" ]; then
    echo "Blocked: $block_reason ($llm_reason)." >&2
  elif [ -n "$heuristic_reason" ]; then
    echo "Blocked: $block_reason ($heuristic_reason)." >&2
  else
    echo "Blocked: $block_reason." >&2
  fi
  exit 126
fi

bash "$tmp_script" "$@"
exit $?
