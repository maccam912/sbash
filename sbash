#!/usr/bin/env bash
set -u

MODE="${SBASH_MODE:-normal}"
NO_AI="${SBASH_NO_AI:-0}"
TIMEOUT_MS="${SBASH_TIMEOUT_MS:-6000}"
EXPLAIN="${SBASH_EXPLAIN:-0}"
ALLOW_ON_ERROR="${SBASH_ALLOW_ON_ERROR:-}"
LLM_URL="${SBASH_LLM_URL:-}"
LLM_KEY="${SBASH_LLM_API_KEY:-}"
SCRIPT_SOURCE_URL="${SBASH_SOURCE_URL:-${SCRIPT_SOURCE_URL:-}}"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
RULES_FILE="${SBASH_RULES_FILE:-$SCRIPT_DIR/rules/heuristic_rules.tsv}"

if [ "$MODE" != "normal" ] && [ "$MODE" != "cautious" ]; then
  MODE="normal"
fi

if [ -z "$ALLOW_ON_ERROR" ]; then
  if [ "$MODE" = "cautious" ]; then
    ALLOW_ON_ERROR="0"
  else
    ALLOW_ON_ERROR="1"
  fi
fi

should_allow_on_error() {
  case "$ALLOW_ON_ERROR" in
    1|true|TRUE|yes|YES|on|ON)
      return 0
      ;;
  esac
  return 1
}

print_explain() {
  case "$EXPLAIN" in
    1|true|TRUE|yes|YES) ;;
    *) return 0 ;;
  esac
  echo "sbash explain: mode=$MODE heuristic=$heuristic_level provider=$selected_provider ai_decision=$llm_decision allow=$allow" >&2
}

selected_provider="none"
provider_method="none"
provider_status="sbash: no LLM provider found; running without AI review"

select_provider() {
  if command -v codex >/dev/null 2>&1; then
    selected_provider="codex"
    provider_method="cli"
    provider_status="sbash: using codex CLI"
    return
  fi

  if command -v claude >/dev/null 2>&1; then
    selected_provider="claude"
    provider_method="cli"
    provider_status="sbash: using claude CLI"
    return
  fi

  if command -v gemini >/dev/null 2>&1; then
    selected_provider="gemini"
    provider_method="cli"
    provider_status="sbash: using gemini CLI"
    return
  fi

  if [ -n "${OPENAI_API_KEY:-}" ]; then
    selected_provider="openai"
    provider_method="api_key"
    provider_status="sbash: using OpenAI key"
    return
  fi

  if [ -n "${ANTHROPIC_API_KEY:-}" ]; then
    selected_provider="anthropic"
    provider_method="api_key"
    provider_status="sbash: using Anthropic key"
    return
  fi

  if [ -n "${GEMINI_API_KEY:-}" ]; then
    selected_provider="gemini"
    provider_method="api_key"
    provider_status="sbash: using Gemini key"
    return
  fi

  if [ -n "${OPENROUTER_API_KEY:-}" ]; then
    selected_provider="openrouter"
    provider_method="api_key"
    provider_status="sbash: using OpenRouter key"
    return
  fi
}

build_review_prompt() {
  # $1 = heuristic level, $2 = script text
  local heuristic="$1"
  local script="$2"
  local line_count
  local source_line=""

  line_count="$(printf '%s\n' "$script" | wc -l | awk '{print $1}')"
  if [ -n "$SCRIPT_SOURCE_URL" ]; then
    source_line="- source_url: $SCRIPT_SOURCE_URL\n"
  fi

  cat <<PROMPT
Role: quick triage for shell installer scripts.
Return JSON only (no markdown, no prose before/after). Use this exact schema:
{"decision":"allow|block|uncertain","reason":"short string","confidence":"low|medium|high"}
Instruction: prefer "uncertain" over over-asserting when evidence is incomplete.

Input:
- heuristic_level: $heuristic
${source_line}- size_lines: $line_count
- script_content:
$script
PROMPT
}

invoke_provider() {
  # $1 = prompt, $2 = output file
  local prompt="$1"
  local out="$2"
  local timeout_s=""
  local run_prefix=""

  timeout_s="$(python3 -c 'import math,sys
try:
  ms=max(1,int(sys.argv[1]))
except Exception:
  ms=6000
print(max(1,math.ceil(ms/1000)))
' "$TIMEOUT_MS" 2>/dev/null || printf '6')"

  if command -v timeout >/dev/null 2>&1; then
    run_prefix="timeout $timeout_s"
  fi

  if [ "$provider_method" = "cli" ]; then
    case "$selected_provider" in
      codex)
        if [ -n "$run_prefix" ]; then
          timeout "$timeout_s" codex "$prompt" >"$out" 2>/dev/null
        else
          codex "$prompt" >"$out" 2>/dev/null
        fi
        return $?
        ;;
      claude)
        if [ -n "$run_prefix" ]; then
          timeout "$timeout_s" claude "$prompt" >"$out" 2>/dev/null
        else
          claude "$prompt" >"$out" 2>/dev/null
        fi
        return $?
        ;;
      gemini)
        if [ -n "$run_prefix" ]; then
          timeout "$timeout_s" gemini "$prompt" >"$out" 2>/dev/null
        else
          gemini "$prompt" >"$out" 2>/dev/null
        fi
        return $?
        ;;
    esac
    return 1
  fi

  if [ "$provider_method" = "api_key" ]; then
    [ -n "$LLM_URL" ] || return 1
    [ -n "${LLM_KEY:-}" ] || LLM_KEY="${OPENAI_API_KEY:-${ANTHROPIC_API_KEY:-${GEMINI_API_KEY:-${OPENROUTER_API_KEY:-}}}}"
    [ -n "$LLM_KEY" ] || return 1

    curl -sS --max-time "$(python3 -c 'import sys
try:
  ms=max(1,int(sys.argv[1]))
except Exception:
  ms=6000
print(f"{ms/1000:.3f}")
' "$TIMEOUT_MS" 2>/dev/null || printf '6')" -X POST "$LLM_URL" \
      -H "Content-Type: application/json" \
      -H "Authorization: Bearer $LLM_KEY" \
      -d "$(printf '%s' "$prompt" | python3 -c 'import json,sys; print(json.dumps({"prompt": sys.stdin.read(), "max_tokens": 120}))')" \
      >"$out"
    return $?
  fi

  return 1
}

tmp_script=""
tmp_ai=""
cleanup() {
  [ -n "$tmp_script" ] && [ -f "$tmp_script" ] && rm -f "$tmp_script"
  [ -n "$tmp_ai" ] && [ -f "$tmp_ai" ] && rm -f "$tmp_ai"
}
trap cleanup EXIT INT TERM

if [ -t 0 ]; then
  exec bash "$@"
fi

tmp_script="$(mktemp)" || {
  echo "sbash: failed to create temp file" >&2
  exit 1
}

cat >"$tmp_script"
script_text="$(cat "$tmp_script")"

heuristic_level="clean"
heuristic_reason=""
heuristic_rule_risk=""

evaluate_heuristics() {
  local script="$1"
  local rule_line=""
  local severity=""
  local pattern=""
  local reason=""
  local risk=""

  if [ ! -f "$RULES_FILE" ]; then
    echo "sbash: rules file not found: $RULES_FILE" >&2
    return 1
  fi

  while IFS=$'\t' read -r severity pattern reason risk; do
    [ -n "$severity" ] || continue
    case "$severity" in
      \#*)
        continue
        ;;
    esac

    if printf '%s\n' "$script" | grep -Eiq "$pattern"; then
      heuristic_level="$severity"
      heuristic_reason="$reason"
      heuristic_rule_risk="$risk"
      return 0
    fi
  done <"$RULES_FILE"

  heuristic_level="clean"
  heuristic_reason="no heuristic rule matched"
  heuristic_rule_risk="none"
  return 0
}

if ! evaluate_heuristics "$script_text"; then
  echo "Blocked: failed to evaluate heuristic rules." >&2
  exit 126
fi

if [ "$heuristic_level" = "high-confidence malicious" ]; then
  echo "Blocked: $heuristic_reason (false-positive risk: $heuristic_rule_risk)." >&2
  exit 126
fi

llm_decision="unknown"
llm_reason=""
llm_parse_warning=""
allow="yes"
block_reason=""

select_provider

case "$NO_AI" in
  1|true|TRUE|yes|YES)
    llm_decision="skipped"
    llm_reason="AI disabled by SBASH_NO_AI"
    ;;
  *)
    if [ "$selected_provider" = "none" ]; then
      echo "$provider_status" >&2
      allow="no"
      block_reason="AI review required but no provider is available"
    else
      echo "$provider_status" >&2
      tmp_ai="$(mktemp)" || {
        echo "sbash: failed to create temp file" >&2
        exit 1
      }

      prompt="$(build_review_prompt "$heuristic_level" "$script_text")"

      if ! invoke_provider "$prompt" "$tmp_ai"; then
        if should_allow_on_error; then
          llm_decision="allow"
          llm_reason="provider failure allowed by policy"
        else
          llm_decision="uncertain"
          llm_reason="provider failure"
        fi
        echo "sbash: provider call failed; applying error policy" >&2
      fi

      ai_json="$(cat "$tmp_ai")"
      # Parse JSON from provider response. llm_decision stays "unknown" until
      # parsing succeeds or the error-policy fallback below runs.
      parsed_fields="$(printf '%s' "$ai_json" | python3 -c 'import json,sys
raw=sys.stdin.read().strip()
if not raw:
  sys.exit(2)
start=raw.find("{")
end=raw.rfind("}")
if start==-1 or end==-1 or end<start:
  sys.exit(2)
obj=json.loads(raw[start:end+1])
if not isinstance(obj,dict):
  sys.exit(2)
d=str(obj.get("decision",""))
r=str(obj.get("reason",""))
print(d.lower())
print(r.strip())
' 2>/dev/null)"

      if [ -n "$parsed_fields" ] && [ "$llm_decision" = "unknown" ]; then
        # Successful parse: pull decision and reason from the provider JSON.
        llm_decision="$(printf '%s\n' "$parsed_fields" | sed -n '1p')"
        llm_reason="$(printf '%s\n' "$parsed_fields" | sed -n '2p')"
      elif [ "$llm_decision" = "unknown" ]; then
        # Provider call succeeded but returned unparseable JSON; apply error policy.
        if should_allow_on_error; then
          llm_decision="allow"
          llm_reason="invalid AI JSON response"
          llm_parse_warning="invalid JSON from AI; allowed by error policy"
        else
          llm_decision="uncertain"
          llm_reason="invalid AI JSON response"
          llm_parse_warning="invalid JSON from AI; defaulted to uncertain"
        fi
      fi
    fi
    ;;
esac

if [ "$MODE" = "cautious" ]; then
  if [ "$heuristic_level" = "suspicious" ] && [ "$llm_decision" != "allow" ]; then
    allow="no"
    block_reason="suspicious script in cautious mode"
  elif [ "$llm_decision" = "block" ] || [ "$llm_decision" = "uncertain" ]; then
    allow="no"
    block_reason="AI checker did not confidently allow script"
  fi
else
  if [ "$llm_decision" = "block" ]; then
    allow="no"
    block_reason="AI checker flagged script"
  fi
fi

if [ -n "$llm_parse_warning" ]; then
  echo "sbash: $llm_parse_warning" >&2
fi

print_explain

if [ "$allow" != "yes" ]; then
  if [ -n "$llm_reason" ]; then
    echo "Blocked: $block_reason ($llm_reason)." >&2
  elif [ -n "$heuristic_reason" ]; then
    echo "Blocked: $block_reason ($heuristic_reason)." >&2
  else
    echo "Blocked: $block_reason." >&2
  fi
  exit 126
fi

bash "$tmp_script" "$@"
exit $?
